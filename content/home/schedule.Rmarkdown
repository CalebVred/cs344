---
widget: blank
headless: true
design:
  # Choose how many columns the section has. Valid values: 1 or 2.
  columns: '1'

title: "Schedule"
weight: 5
---

```{r setup, include=FALSE}
library(tidyverse)
library(glue)
library(lubridate)
# devtools::install_github("kcarnold/daily")
library(daily)
```


## Schedule

```{r echo=FALSE, results='asis'}
# Note: this could use <details> for the nested tree; I think `<details open>` will work
# https://gist.github.com/ericclemmons/b146fe5da72ca1f706b2ef72a20ac39d


add_prefix <- function(s, prefix) {
  str_replace_all(s, regex("^", multiline = TRUE), prefix)
}

daily2cal(
  path = here::here("daily.txt"),
  end = lubridate::ymd("2021-02-12"),
) %>%
  pivot_longer(-c(date, week), names_to = "label", values_to = "contents") %>% 
  filter(
    !(str_to_lower(label) %in% c("log", "reflection", "next time")),
    !is.na(contents)) %>% 
  mutate(contents = if_else(
    label %in% c("Quiz"),
    str_extract(contents, regex("^[^\\n]+$", multiline = TRUE)),
    contents
  )) %>% 
  mutate(
    topic_contents = glue("* **{label}**\n{add_prefix(contents, '    ')}")) %>% 
  group_by(week, date) %>% 
  summarize(
    date = first(date),
    date = glue("{wday(date, label = TRUE)} {month(date)}/{mday(date)}"),
    day_contents = glue("* {first(date)}\n\n{paste0(add_prefix(topic_contents, '    '), collapse = '\n')}"), .groups = "drop") %>% 
  summarize(markdown = str_c(day_contents, collapse = "\n"), .groups="drop") %>% 
  pull(markdown) %>% 
  cat()
```

```{r include=TRUE}
#' A version of purrr::accumulate that maintains the data type of the input.
#
# Needed because accumulate with dates coerces to `dbl`.

accumulate_custom <- function(x, f) {
  res <- x
  prev <- x[[1]]
  for(i in seq_along(x)) {
    if (i == 1) next;
    res[[i]] <- prev <- f(prev, x[[i]])
  }
  res
}

mask <- daily:::days2mask("MWF")
x <- here::here("daily.txt") %>% 
  read_lines() %>% 
  tibble(line = .) %>% 
  mutate(is_delim = str_starts(line, "==="), day_spec = cumsum(is_delim)) %>% 
  group_by(day_spec) %>% 
  summarize(daysep = first(line), rest = list(line)) %>% 
  filter(day_spec > 0) %>% 
  # remove `===` prefix
  mutate(daysep = str_sub(daysep, start = 4)) %>% 
  # mark skipped days (TODO handle)
  mutate(skip = str_detect(daysep, "skip")) %>% 
  # stop before end of calendar
  mutate(hit_end = cumsum(str_detect(daysep, "endofcal"))) %>% 
  filter(hit_end == 0) %>% 
  mutate(day = lubridate::mdy(daysep)) %>% 
  select(-daysep) %>% 
  # Fill in unspecified days
  mutate(day2 = accumulate_custom(day, function(prev_day, day) {
    if (is.na(day)) daily:::next_cal_day(prev_day, mask)
    else day
  }))
x
```

```{r}

accumulate_custom(x$day, function(prev_day, day) {
    if (is.na(day)) daily:::next_cal_day(prev_day, mask)
    else day
  })
```





Overall, we will go through the first half of the Deep Learning for Coders book
at the pace that works for us, then see where we are. Then we will plan together
what remaining topics to discuss, such as:

* language processing (my specific area of interest), especially Transformers
* reinforcement learning
* unsupervised learning
* others as we identify them
